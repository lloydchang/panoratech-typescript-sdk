/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  UnifiedTicketingAttachmentInput,
  UnifiedTicketingAttachmentInput$inboundSchema,
  UnifiedTicketingAttachmentInput$Outbound,
  UnifiedTicketingAttachmentInput$outboundSchema,
} from "./unifiedticketingattachmentinput.js";
import {
  UnifiedTicketingAttachmentOutput,
  UnifiedTicketingAttachmentOutput$inboundSchema,
  UnifiedTicketingAttachmentOutput$Outbound,
  UnifiedTicketingAttachmentOutput$outboundSchema,
} from "./unifiedticketingattachmentoutput.js";
import {
  UnifiedTicketingCollectionOutput,
  UnifiedTicketingCollectionOutput$inboundSchema,
  UnifiedTicketingCollectionOutput$Outbound,
  UnifiedTicketingCollectionOutput$outboundSchema,
} from "./unifiedticketingcollectionoutput.js";
import {
  UnifiedTicketingTagOutput,
  UnifiedTicketingTagOutput$inboundSchema,
  UnifiedTicketingTagOutput$Outbound,
  UnifiedTicketingTagOutput$outboundSchema,
} from "./unifiedticketingtagoutput.js";

export type UnifiedTicketingTicketInputCollections =
  | UnifiedTicketingCollectionOutput
  | string;

export type UnifiedTicketingTicketInputTags =
  | UnifiedTicketingTagOutput
  | string;

export type UnifiedTicketingTicketInputCommentAttachments =
  | UnifiedTicketingAttachmentOutput
  | string;

/**
 * The comment of the ticket
 */
export type UnifiedTicketingTicketInputComment = {
  /**
   * The body of the comment
   */
  body: string | null;
  /**
   * The html body of the comment
   */
  htmlBody?: string | null | undefined;
  /**
   * The public status of the comment
   */
  isPrivate?: boolean | null | undefined;
  /**
   * The creator type of the comment. Authorized values are either USER or CONTACT
   */
  creatorType?: string | null | undefined;
  /**
   * The UUID of the ticket the comment is tied to
   */
  ticketId?: string | null | undefined;
  /**
   * The UUID of the contact which the comment belongs to (if no user_id specified)
   */
  contactId?: string | null | undefined;
  /**
   * The UUID of the user which the comment belongs to (if no contact_id specified)
   */
  userId?: string | null | undefined;
  /**
   * The attachements UUIDs tied to the comment
   */
  attachments?:
    | Array<UnifiedTicketingAttachmentOutput | string>
    | null
    | undefined;
};

export type UnifiedTicketingTicketInputAttachments =
  | UnifiedTicketingAttachmentInput
  | string;

export type UnifiedTicketingTicketInput = {
  /**
   * The name of the ticket
   */
  name: string | null;
  /**
   * The status of the ticket. Authorized values are OPEN or CLOSED.
   */
  status?: string | null | undefined;
  /**
   * The description of the ticket
   */
  description: string | null;
  /**
   * The date the ticket is due
   */
  dueDate?: Date | null | undefined;
  /**
   * The type of the ticket. Authorized values are PROBLEM, QUESTION, or TASK
   */
  type?: string | null | undefined;
  /**
   * The UUID of the parent ticket
   */
  parentTicket?: string | null | undefined;
  /**
   * The collection UUIDs the ticket belongs to
   */
  collections?:
    | Array<UnifiedTicketingCollectionOutput | string>
    | null
    | undefined;
  /**
   * The tags names of the ticket
   */
  tags?: Array<UnifiedTicketingTagOutput | string> | null | undefined;
  /**
   * The date the ticket has been completed
   */
  completedAt?: Date | null | undefined;
  /**
   * The priority of the ticket. Authorized values are HIGH, MEDIUM or LOW.
   */
  priority?: string | null | undefined;
  /**
   * The users UUIDs the ticket is assigned to
   */
  assignedTo?: Array<string> | null | undefined;
  /**
   * The comment of the ticket
   */
  comment?: UnifiedTicketingTicketInputComment | null | undefined;
  /**
   * The UUID of the account which the ticket belongs to
   */
  accountId?: string | null | undefined;
  /**
   * The UUID of the contact which the ticket belongs to
   */
  contactId?: string | null | undefined;
  /**
   * The attachements UUIDs tied to the ticket
   */
  attachments?:
    | Array<UnifiedTicketingAttachmentInput | string>
    | null
    | undefined;
  /**
   * The custom field mappings of the ticket between the remote 3rd party & Panora
   */
  fieldMappings?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const UnifiedTicketingTicketInputCollections$inboundSchema: z.ZodType<
  UnifiedTicketingTicketInputCollections,
  z.ZodTypeDef,
  unknown
> = z.union([UnifiedTicketingCollectionOutput$inboundSchema, z.string()]);

/** @internal */
export type UnifiedTicketingTicketInputCollections$Outbound =
  | UnifiedTicketingCollectionOutput$Outbound
  | string;

/** @internal */
export const UnifiedTicketingTicketInputCollections$outboundSchema: z.ZodType<
  UnifiedTicketingTicketInputCollections$Outbound,
  z.ZodTypeDef,
  UnifiedTicketingTicketInputCollections
> = z.union([UnifiedTicketingCollectionOutput$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UnifiedTicketingTicketInputCollections$ {
  /** @deprecated use `UnifiedTicketingTicketInputCollections$inboundSchema` instead. */
  export const inboundSchema =
    UnifiedTicketingTicketInputCollections$inboundSchema;
  /** @deprecated use `UnifiedTicketingTicketInputCollections$outboundSchema` instead. */
  export const outboundSchema =
    UnifiedTicketingTicketInputCollections$outboundSchema;
  /** @deprecated use `UnifiedTicketingTicketInputCollections$Outbound` instead. */
  export type Outbound = UnifiedTicketingTicketInputCollections$Outbound;
}

export function unifiedTicketingTicketInputCollectionsToJSON(
  unifiedTicketingTicketInputCollections:
    UnifiedTicketingTicketInputCollections,
): string {
  return JSON.stringify(
    UnifiedTicketingTicketInputCollections$outboundSchema.parse(
      unifiedTicketingTicketInputCollections,
    ),
  );
}

export function unifiedTicketingTicketInputCollectionsFromJSON(
  jsonString: string,
): SafeParseResult<UnifiedTicketingTicketInputCollections, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UnifiedTicketingTicketInputCollections$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UnifiedTicketingTicketInputCollections' from JSON`,
  );
}

/** @internal */
export const UnifiedTicketingTicketInputTags$inboundSchema: z.ZodType<
  UnifiedTicketingTicketInputTags,
  z.ZodTypeDef,
  unknown
> = z.union([UnifiedTicketingTagOutput$inboundSchema, z.string()]);

/** @internal */
export type UnifiedTicketingTicketInputTags$Outbound =
  | UnifiedTicketingTagOutput$Outbound
  | string;

/** @internal */
export const UnifiedTicketingTicketInputTags$outboundSchema: z.ZodType<
  UnifiedTicketingTicketInputTags$Outbound,
  z.ZodTypeDef,
  UnifiedTicketingTicketInputTags
> = z.union([UnifiedTicketingTagOutput$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UnifiedTicketingTicketInputTags$ {
  /** @deprecated use `UnifiedTicketingTicketInputTags$inboundSchema` instead. */
  export const inboundSchema = UnifiedTicketingTicketInputTags$inboundSchema;
  /** @deprecated use `UnifiedTicketingTicketInputTags$outboundSchema` instead. */
  export const outboundSchema = UnifiedTicketingTicketInputTags$outboundSchema;
  /** @deprecated use `UnifiedTicketingTicketInputTags$Outbound` instead. */
  export type Outbound = UnifiedTicketingTicketInputTags$Outbound;
}

export function unifiedTicketingTicketInputTagsToJSON(
  unifiedTicketingTicketInputTags: UnifiedTicketingTicketInputTags,
): string {
  return JSON.stringify(
    UnifiedTicketingTicketInputTags$outboundSchema.parse(
      unifiedTicketingTicketInputTags,
    ),
  );
}

export function unifiedTicketingTicketInputTagsFromJSON(
  jsonString: string,
): SafeParseResult<UnifiedTicketingTicketInputTags, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UnifiedTicketingTicketInputTags$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UnifiedTicketingTicketInputTags' from JSON`,
  );
}

/** @internal */
export const UnifiedTicketingTicketInputCommentAttachments$inboundSchema:
  z.ZodType<
    UnifiedTicketingTicketInputCommentAttachments,
    z.ZodTypeDef,
    unknown
  > = z.union([UnifiedTicketingAttachmentOutput$inboundSchema, z.string()]);

/** @internal */
export type UnifiedTicketingTicketInputCommentAttachments$Outbound =
  | UnifiedTicketingAttachmentOutput$Outbound
  | string;

/** @internal */
export const UnifiedTicketingTicketInputCommentAttachments$outboundSchema:
  z.ZodType<
    UnifiedTicketingTicketInputCommentAttachments$Outbound,
    z.ZodTypeDef,
    UnifiedTicketingTicketInputCommentAttachments
  > = z.union([UnifiedTicketingAttachmentOutput$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UnifiedTicketingTicketInputCommentAttachments$ {
  /** @deprecated use `UnifiedTicketingTicketInputCommentAttachments$inboundSchema` instead. */
  export const inboundSchema =
    UnifiedTicketingTicketInputCommentAttachments$inboundSchema;
  /** @deprecated use `UnifiedTicketingTicketInputCommentAttachments$outboundSchema` instead. */
  export const outboundSchema =
    UnifiedTicketingTicketInputCommentAttachments$outboundSchema;
  /** @deprecated use `UnifiedTicketingTicketInputCommentAttachments$Outbound` instead. */
  export type Outbound = UnifiedTicketingTicketInputCommentAttachments$Outbound;
}

export function unifiedTicketingTicketInputCommentAttachmentsToJSON(
  unifiedTicketingTicketInputCommentAttachments:
    UnifiedTicketingTicketInputCommentAttachments,
): string {
  return JSON.stringify(
    UnifiedTicketingTicketInputCommentAttachments$outboundSchema.parse(
      unifiedTicketingTicketInputCommentAttachments,
    ),
  );
}

export function unifiedTicketingTicketInputCommentAttachmentsFromJSON(
  jsonString: string,
): SafeParseResult<
  UnifiedTicketingTicketInputCommentAttachments,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UnifiedTicketingTicketInputCommentAttachments$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UnifiedTicketingTicketInputCommentAttachments' from JSON`,
  );
}

/** @internal */
export const UnifiedTicketingTicketInputComment$inboundSchema: z.ZodType<
  UnifiedTicketingTicketInputComment,
  z.ZodTypeDef,
  unknown
> = z.object({
  body: z.nullable(z.string()),
  html_body: z.nullable(z.string()).optional(),
  is_private: z.nullable(z.boolean()).optional(),
  creator_type: z.nullable(z.string()).optional(),
  ticket_id: z.nullable(z.string()).optional(),
  contact_id: z.nullable(z.string()).optional(),
  user_id: z.nullable(z.string()).optional(),
  attachments: z.nullable(
    z.array(
      z.union([UnifiedTicketingAttachmentOutput$inboundSchema, z.string()]),
    ),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "html_body": "htmlBody",
    "is_private": "isPrivate",
    "creator_type": "creatorType",
    "ticket_id": "ticketId",
    "contact_id": "contactId",
    "user_id": "userId",
  });
});

/** @internal */
export type UnifiedTicketingTicketInputComment$Outbound = {
  body: string | null;
  html_body?: string | null | undefined;
  is_private?: boolean | null | undefined;
  creator_type?: string | null | undefined;
  ticket_id?: string | null | undefined;
  contact_id?: string | null | undefined;
  user_id?: string | null | undefined;
  attachments?:
    | Array<UnifiedTicketingAttachmentOutput$Outbound | string>
    | null
    | undefined;
};

/** @internal */
export const UnifiedTicketingTicketInputComment$outboundSchema: z.ZodType<
  UnifiedTicketingTicketInputComment$Outbound,
  z.ZodTypeDef,
  UnifiedTicketingTicketInputComment
> = z.object({
  body: z.nullable(z.string()),
  htmlBody: z.nullable(z.string()).optional(),
  isPrivate: z.nullable(z.boolean()).optional(),
  creatorType: z.nullable(z.string()).optional(),
  ticketId: z.nullable(z.string()).optional(),
  contactId: z.nullable(z.string()).optional(),
  userId: z.nullable(z.string()).optional(),
  attachments: z.nullable(
    z.array(
      z.union([UnifiedTicketingAttachmentOutput$outboundSchema, z.string()]),
    ),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    htmlBody: "html_body",
    isPrivate: "is_private",
    creatorType: "creator_type",
    ticketId: "ticket_id",
    contactId: "contact_id",
    userId: "user_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UnifiedTicketingTicketInputComment$ {
  /** @deprecated use `UnifiedTicketingTicketInputComment$inboundSchema` instead. */
  export const inboundSchema = UnifiedTicketingTicketInputComment$inboundSchema;
  /** @deprecated use `UnifiedTicketingTicketInputComment$outboundSchema` instead. */
  export const outboundSchema =
    UnifiedTicketingTicketInputComment$outboundSchema;
  /** @deprecated use `UnifiedTicketingTicketInputComment$Outbound` instead. */
  export type Outbound = UnifiedTicketingTicketInputComment$Outbound;
}

export function unifiedTicketingTicketInputCommentToJSON(
  unifiedTicketingTicketInputComment: UnifiedTicketingTicketInputComment,
): string {
  return JSON.stringify(
    UnifiedTicketingTicketInputComment$outboundSchema.parse(
      unifiedTicketingTicketInputComment,
    ),
  );
}

export function unifiedTicketingTicketInputCommentFromJSON(
  jsonString: string,
): SafeParseResult<UnifiedTicketingTicketInputComment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UnifiedTicketingTicketInputComment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UnifiedTicketingTicketInputComment' from JSON`,
  );
}

/** @internal */
export const UnifiedTicketingTicketInputAttachments$inboundSchema: z.ZodType<
  UnifiedTicketingTicketInputAttachments,
  z.ZodTypeDef,
  unknown
> = z.union([UnifiedTicketingAttachmentInput$inboundSchema, z.string()]);

/** @internal */
export type UnifiedTicketingTicketInputAttachments$Outbound =
  | UnifiedTicketingAttachmentInput$Outbound
  | string;

/** @internal */
export const UnifiedTicketingTicketInputAttachments$outboundSchema: z.ZodType<
  UnifiedTicketingTicketInputAttachments$Outbound,
  z.ZodTypeDef,
  UnifiedTicketingTicketInputAttachments
> = z.union([UnifiedTicketingAttachmentInput$outboundSchema, z.string()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UnifiedTicketingTicketInputAttachments$ {
  /** @deprecated use `UnifiedTicketingTicketInputAttachments$inboundSchema` instead. */
  export const inboundSchema =
    UnifiedTicketingTicketInputAttachments$inboundSchema;
  /** @deprecated use `UnifiedTicketingTicketInputAttachments$outboundSchema` instead. */
  export const outboundSchema =
    UnifiedTicketingTicketInputAttachments$outboundSchema;
  /** @deprecated use `UnifiedTicketingTicketInputAttachments$Outbound` instead. */
  export type Outbound = UnifiedTicketingTicketInputAttachments$Outbound;
}

export function unifiedTicketingTicketInputAttachmentsToJSON(
  unifiedTicketingTicketInputAttachments:
    UnifiedTicketingTicketInputAttachments,
): string {
  return JSON.stringify(
    UnifiedTicketingTicketInputAttachments$outboundSchema.parse(
      unifiedTicketingTicketInputAttachments,
    ),
  );
}

export function unifiedTicketingTicketInputAttachmentsFromJSON(
  jsonString: string,
): SafeParseResult<UnifiedTicketingTicketInputAttachments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UnifiedTicketingTicketInputAttachments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UnifiedTicketingTicketInputAttachments' from JSON`,
  );
}

/** @internal */
export const UnifiedTicketingTicketInput$inboundSchema: z.ZodType<
  UnifiedTicketingTicketInput,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.nullable(z.string()),
  status: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()),
  due_date: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  type: z.nullable(z.string()).optional(),
  parent_ticket: z.nullable(z.string()).optional(),
  collections: z.nullable(
    z.array(
      z.union([UnifiedTicketingCollectionOutput$inboundSchema, z.string()]),
    ),
  ).optional(),
  tags: z.nullable(
    z.array(z.union([UnifiedTicketingTagOutput$inboundSchema, z.string()])),
  ).optional(),
  completed_at: z.nullable(
    z.string().datetime({ offset: true }).transform(v => new Date(v)),
  ).optional(),
  priority: z.nullable(z.string()).optional(),
  assigned_to: z.nullable(z.array(z.string())).optional(),
  comment: z.nullable(
    z.lazy(() => UnifiedTicketingTicketInputComment$inboundSchema),
  ).optional(),
  account_id: z.nullable(z.string()).optional(),
  contact_id: z.nullable(z.string()).optional(),
  attachments: z.nullable(
    z.array(
      z.union([UnifiedTicketingAttachmentInput$inboundSchema, z.string()]),
    ),
  ).optional(),
  field_mappings: z.nullable(z.record(z.any())).optional(),
}).transform((v) => {
  return remap$(v, {
    "due_date": "dueDate",
    "parent_ticket": "parentTicket",
    "completed_at": "completedAt",
    "assigned_to": "assignedTo",
    "account_id": "accountId",
    "contact_id": "contactId",
    "field_mappings": "fieldMappings",
  });
});

/** @internal */
export type UnifiedTicketingTicketInput$Outbound = {
  name: string | null;
  status?: string | null | undefined;
  description: string | null;
  due_date?: string | null | undefined;
  type?: string | null | undefined;
  parent_ticket?: string | null | undefined;
  collections?:
    | Array<UnifiedTicketingCollectionOutput$Outbound | string>
    | null
    | undefined;
  tags?: Array<UnifiedTicketingTagOutput$Outbound | string> | null | undefined;
  completed_at?: string | null | undefined;
  priority?: string | null | undefined;
  assigned_to?: Array<string> | null | undefined;
  comment?: UnifiedTicketingTicketInputComment$Outbound | null | undefined;
  account_id?: string | null | undefined;
  contact_id?: string | null | undefined;
  attachments?:
    | Array<UnifiedTicketingAttachmentInput$Outbound | string>
    | null
    | undefined;
  field_mappings?: { [k: string]: any } | null | undefined;
};

/** @internal */
export const UnifiedTicketingTicketInput$outboundSchema: z.ZodType<
  UnifiedTicketingTicketInput$Outbound,
  z.ZodTypeDef,
  UnifiedTicketingTicketInput
> = z.object({
  name: z.nullable(z.string()),
  status: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()),
  dueDate: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  type: z.nullable(z.string()).optional(),
  parentTicket: z.nullable(z.string()).optional(),
  collections: z.nullable(
    z.array(
      z.union([UnifiedTicketingCollectionOutput$outboundSchema, z.string()]),
    ),
  ).optional(),
  tags: z.nullable(
    z.array(z.union([UnifiedTicketingTagOutput$outboundSchema, z.string()])),
  ).optional(),
  completedAt: z.nullable(z.date().transform(v => v.toISOString())).optional(),
  priority: z.nullable(z.string()).optional(),
  assignedTo: z.nullable(z.array(z.string())).optional(),
  comment: z.nullable(
    z.lazy(() => UnifiedTicketingTicketInputComment$outboundSchema),
  ).optional(),
  accountId: z.nullable(z.string()).optional(),
  contactId: z.nullable(z.string()).optional(),
  attachments: z.nullable(
    z.array(
      z.union([UnifiedTicketingAttachmentInput$outboundSchema, z.string()]),
    ),
  ).optional(),
  fieldMappings: z.nullable(z.record(z.any())).optional(),
}).transform((v) => {
  return remap$(v, {
    dueDate: "due_date",
    parentTicket: "parent_ticket",
    completedAt: "completed_at",
    assignedTo: "assigned_to",
    accountId: "account_id",
    contactId: "contact_id",
    fieldMappings: "field_mappings",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UnifiedTicketingTicketInput$ {
  /** @deprecated use `UnifiedTicketingTicketInput$inboundSchema` instead. */
  export const inboundSchema = UnifiedTicketingTicketInput$inboundSchema;
  /** @deprecated use `UnifiedTicketingTicketInput$outboundSchema` instead. */
  export const outboundSchema = UnifiedTicketingTicketInput$outboundSchema;
  /** @deprecated use `UnifiedTicketingTicketInput$Outbound` instead. */
  export type Outbound = UnifiedTicketingTicketInput$Outbound;
}

export function unifiedTicketingTicketInputToJSON(
  unifiedTicketingTicketInput: UnifiedTicketingTicketInput,
): string {
  return JSON.stringify(
    UnifiedTicketingTicketInput$outboundSchema.parse(
      unifiedTicketingTicketInput,
    ),
  );
}

export function unifiedTicketingTicketInputFromJSON(
  jsonString: string,
): SafeParseResult<UnifiedTicketingTicketInput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UnifiedTicketingTicketInput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UnifiedTicketingTicketInput' from JSON`,
  );
}
